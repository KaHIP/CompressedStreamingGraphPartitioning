// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_STREAMCPIINFO_STREAMCPIINFO_H_
#define FLATBUFFERS_GENERATED_STREAMCPIINFO_STREAMCPIINFO_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace StreamCPIInfo {

struct Partition;
struct PartitionBuilder;

struct GraphMetadata;
struct GraphMetadataBuilder;

struct PartitionConfiguration;
struct PartitionConfigurationBuilder;

struct RunTime;
struct RunTimeBuilder;

struct PartitionMetrics;
struct PartitionMetricsBuilder;

struct MemoryConsumption;
struct MemoryConsumptionBuilder;

struct Partition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartitionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRAPH_METADATA = 4,
    VT_PARTITION_CONFIGURATION = 6,
    VT_RUNTIME = 8,
    VT_MEMORY_CONSUMPTION = 10,
    VT_METRICS = 12
  };
  const StreamCPIInfo::GraphMetadata *graph_metadata() const {
    return GetPointer<const StreamCPIInfo::GraphMetadata *>(VT_GRAPH_METADATA);
  }
  const StreamCPIInfo::PartitionConfiguration *partition_configuration() const {
    return GetPointer<const StreamCPIInfo::PartitionConfiguration *>(VT_PARTITION_CONFIGURATION);
  }
  const StreamCPIInfo::RunTime *runtime() const {
    return GetPointer<const StreamCPIInfo::RunTime *>(VT_RUNTIME);
  }
  const StreamCPIInfo::MemoryConsumption *memory_consumption() const {
    return GetPointer<const StreamCPIInfo::MemoryConsumption *>(VT_MEMORY_CONSUMPTION);
  }
  const StreamCPIInfo::PartitionMetrics *metrics() const {
    return GetPointer<const StreamCPIInfo::PartitionMetrics *>(VT_METRICS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GRAPH_METADATA) &&
           verifier.VerifyTable(graph_metadata()) &&
           VerifyOffset(verifier, VT_PARTITION_CONFIGURATION) &&
           verifier.VerifyTable(partition_configuration()) &&
           VerifyOffset(verifier, VT_RUNTIME) &&
           verifier.VerifyTable(runtime()) &&
           VerifyOffset(verifier, VT_MEMORY_CONSUMPTION) &&
           verifier.VerifyTable(memory_consumption()) &&
           VerifyOffset(verifier, VT_METRICS) &&
           verifier.VerifyTable(metrics()) &&
           verifier.EndTable();
  }
};

struct PartitionBuilder {
  typedef Partition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_graph_metadata(::flatbuffers::Offset<StreamCPIInfo::GraphMetadata> graph_metadata) {
    fbb_.AddOffset(Partition::VT_GRAPH_METADATA, graph_metadata);
  }
  void add_partition_configuration(::flatbuffers::Offset<StreamCPIInfo::PartitionConfiguration> partition_configuration) {
    fbb_.AddOffset(Partition::VT_PARTITION_CONFIGURATION, partition_configuration);
  }
  void add_runtime(::flatbuffers::Offset<StreamCPIInfo::RunTime> runtime) {
    fbb_.AddOffset(Partition::VT_RUNTIME, runtime);
  }
  void add_memory_consumption(::flatbuffers::Offset<StreamCPIInfo::MemoryConsumption> memory_consumption) {
    fbb_.AddOffset(Partition::VT_MEMORY_CONSUMPTION, memory_consumption);
  }
  void add_metrics(::flatbuffers::Offset<StreamCPIInfo::PartitionMetrics> metrics) {
    fbb_.AddOffset(Partition::VT_METRICS, metrics);
  }
  explicit PartitionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Partition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Partition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Partition> CreatePartition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<StreamCPIInfo::GraphMetadata> graph_metadata = 0,
    ::flatbuffers::Offset<StreamCPIInfo::PartitionConfiguration> partition_configuration = 0,
    ::flatbuffers::Offset<StreamCPIInfo::RunTime> runtime = 0,
    ::flatbuffers::Offset<StreamCPIInfo::MemoryConsumption> memory_consumption = 0,
    ::flatbuffers::Offset<StreamCPIInfo::PartitionMetrics> metrics = 0) {
  PartitionBuilder builder_(_fbb);
  builder_.add_metrics(metrics);
  builder_.add_memory_consumption(memory_consumption);
  builder_.add_runtime(runtime);
  builder_.add_partition_configuration(partition_configuration);
  builder_.add_graph_metadata(graph_metadata);
  return builder_.Finish();
}

struct GraphMetadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GraphMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILENAME = 4,
    VT_NUM_NODES = 6,
    VT_NUM_EDGES = 8,
    VT_MAX_DEGREE = 10
  };
  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  uint64_t num_nodes() const {
    return GetField<uint64_t>(VT_NUM_NODES, 0);
  }
  uint64_t num_edges() const {
    return GetField<uint64_t>(VT_NUM_EDGES, 0);
  }
  uint64_t max_degree() const {
    return GetField<uint64_t>(VT_MAX_DEGREE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyField<uint64_t>(verifier, VT_NUM_NODES, 8) &&
           VerifyField<uint64_t>(verifier, VT_NUM_EDGES, 8) &&
           VerifyField<uint64_t>(verifier, VT_MAX_DEGREE, 8) &&
           verifier.EndTable();
  }
};

struct GraphMetadataBuilder {
  typedef GraphMetadata Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(GraphMetadata::VT_FILENAME, filename);
  }
  void add_num_nodes(uint64_t num_nodes) {
    fbb_.AddElement<uint64_t>(GraphMetadata::VT_NUM_NODES, num_nodes, 0);
  }
  void add_num_edges(uint64_t num_edges) {
    fbb_.AddElement<uint64_t>(GraphMetadata::VT_NUM_EDGES, num_edges, 0);
  }
  void add_max_degree(uint64_t max_degree) {
    fbb_.AddElement<uint64_t>(GraphMetadata::VT_MAX_DEGREE, max_degree, 0);
  }
  explicit GraphMetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GraphMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GraphMetadata>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GraphMetadata> CreateGraphMetadata(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> filename = 0,
    uint64_t num_nodes = 0,
    uint64_t num_edges = 0,
    uint64_t max_degree = 0) {
  GraphMetadataBuilder builder_(_fbb);
  builder_.add_max_degree(max_degree);
  builder_.add_num_edges(num_edges);
  builder_.add_num_nodes(num_nodes);
  builder_.add_filename(filename);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GraphMetadata> CreateGraphMetadataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *filename = nullptr,
    uint64_t num_nodes = 0,
    uint64_t num_edges = 0,
    uint64_t max_degree = 0) {
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  return StreamCPIInfo::CreateGraphMetadata(
      _fbb,
      filename__,
      num_nodes,
      num_edges,
      max_degree);
}

struct PartitionConfiguration FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartitionConfigurationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_K = 4,
    VT_SEED = 6,
    VT_INPUT_BALANCE = 8,
    VT_SET_PART_ZERO = 10,
    VT_RLE_LENGTH = 12,
    VT_KAPPA = 14
  };
  uint32_t k() const {
    return GetField<uint32_t>(VT_K, 0);
  }
  int32_t seed() const {
    return GetField<int32_t>(VT_SEED, 0);
  }
  double input_balance() const {
    return GetField<double>(VT_INPUT_BALANCE, 0.0);
  }
  int32_t set_part_zero() const {
    return GetField<int32_t>(VT_SET_PART_ZERO, 0);
  }
  uint64_t rle_length() const {
    return GetField<uint64_t>(VT_RLE_LENGTH, 0);
  }
  double kappa() const {
    return GetField<double>(VT_KAPPA, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_K, 4) &&
           VerifyField<int32_t>(verifier, VT_SEED, 4) &&
           VerifyField<double>(verifier, VT_INPUT_BALANCE, 8) &&
           VerifyField<int32_t>(verifier, VT_SET_PART_ZERO, 4) &&
           VerifyField<uint64_t>(verifier, VT_RLE_LENGTH, 8) &&
           VerifyField<double>(verifier, VT_KAPPA, 8) &&
           verifier.EndTable();
  }
};

struct PartitionConfigurationBuilder {
  typedef PartitionConfiguration Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_k(uint32_t k) {
    fbb_.AddElement<uint32_t>(PartitionConfiguration::VT_K, k, 0);
  }
  void add_seed(int32_t seed) {
    fbb_.AddElement<int32_t>(PartitionConfiguration::VT_SEED, seed, 0);
  }
  void add_input_balance(double input_balance) {
    fbb_.AddElement<double>(PartitionConfiguration::VT_INPUT_BALANCE, input_balance, 0.0);
  }
  void add_set_part_zero(int32_t set_part_zero) {
    fbb_.AddElement<int32_t>(PartitionConfiguration::VT_SET_PART_ZERO, set_part_zero, 0);
  }
  void add_rle_length(uint64_t rle_length) {
    fbb_.AddElement<uint64_t>(PartitionConfiguration::VT_RLE_LENGTH, rle_length, 0);
  }
  void add_kappa(double kappa) {
    fbb_.AddElement<double>(PartitionConfiguration::VT_KAPPA, kappa, 0.0);
  }
  explicit PartitionConfigurationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartitionConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartitionConfiguration>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PartitionConfiguration> CreatePartitionConfiguration(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t k = 0,
    int32_t seed = 0,
    double input_balance = 0.0,
    int32_t set_part_zero = 0,
    uint64_t rle_length = 0,
    double kappa = 0.0) {
  PartitionConfigurationBuilder builder_(_fbb);
  builder_.add_kappa(kappa);
  builder_.add_rle_length(rle_length);
  builder_.add_input_balance(input_balance);
  builder_.add_set_part_zero(set_part_zero);
  builder_.add_seed(seed);
  builder_.add_k(k);
  return builder_.Finish();
}

struct RunTime FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RunTimeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IO_TIME = 4,
    VT_MAPPING_TIME = 6,
    VT_TOTAL_TIME = 8
  };
  double io_time() const {
    return GetField<double>(VT_IO_TIME, 0.0);
  }
  double mapping_time() const {
    return GetField<double>(VT_MAPPING_TIME, 0.0);
  }
  double total_time() const {
    return GetField<double>(VT_TOTAL_TIME, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_IO_TIME, 8) &&
           VerifyField<double>(verifier, VT_MAPPING_TIME, 8) &&
           VerifyField<double>(verifier, VT_TOTAL_TIME, 8) &&
           verifier.EndTable();
  }
};

struct RunTimeBuilder {
  typedef RunTime Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_io_time(double io_time) {
    fbb_.AddElement<double>(RunTime::VT_IO_TIME, io_time, 0.0);
  }
  void add_mapping_time(double mapping_time) {
    fbb_.AddElement<double>(RunTime::VT_MAPPING_TIME, mapping_time, 0.0);
  }
  void add_total_time(double total_time) {
    fbb_.AddElement<double>(RunTime::VT_TOTAL_TIME, total_time, 0.0);
  }
  explicit RunTimeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RunTime> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RunTime>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RunTime> CreateRunTime(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double io_time = 0.0,
    double mapping_time = 0.0,
    double total_time = 0.0) {
  RunTimeBuilder builder_(_fbb);
  builder_.add_total_time(total_time);
  builder_.add_mapping_time(mapping_time);
  builder_.add_io_time(io_time);
  return builder_.Finish();
}

struct PartitionMetrics FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartitionMetricsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EDGE_CUT = 4,
    VT_BALANCE = 6
  };
  uint64_t edge_cut() const {
    return GetField<uint64_t>(VT_EDGE_CUT, 0);
  }
  double balance() const {
    return GetField<double>(VT_BALANCE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_EDGE_CUT, 8) &&
           VerifyField<double>(verifier, VT_BALANCE, 8) &&
           verifier.EndTable();
  }
};

struct PartitionMetricsBuilder {
  typedef PartitionMetrics Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_edge_cut(uint64_t edge_cut) {
    fbb_.AddElement<uint64_t>(PartitionMetrics::VT_EDGE_CUT, edge_cut, 0);
  }
  void add_balance(double balance) {
    fbb_.AddElement<double>(PartitionMetrics::VT_BALANCE, balance, 0.0);
  }
  explicit PartitionMetricsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartitionMetrics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartitionMetrics>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PartitionMetrics> CreatePartitionMetrics(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t edge_cut = 0,
    double balance = 0.0) {
  PartitionMetricsBuilder builder_(_fbb);
  builder_.add_balance(balance);
  builder_.add_edge_cut(edge_cut);
  return builder_.Finish();
}

struct MemoryConsumption FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MemoryConsumptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNCOMPRESSED_VEC_BYTES = 4,
    VT_RLE_VECTOR_BYTES = 6,
    VT_RLE_VECTOR_MB = 8,
    VT_RELATIVE_COMPRESSION = 10,
    VT_OVERALL_MAX_RSS = 12
  };
  uint64_t uncompressed_vec_bytes() const {
    return GetField<uint64_t>(VT_UNCOMPRESSED_VEC_BYTES, 0);
  }
  uint64_t rle_vector_bytes() const {
    return GetField<uint64_t>(VT_RLE_VECTOR_BYTES, 0);
  }
  double rle_vector_mb() const {
    return GetField<double>(VT_RLE_VECTOR_MB, 0.0);
  }
  double relative_compression() const {
    return GetField<double>(VT_RELATIVE_COMPRESSION, 0.0);
  }
  int64_t overall_max_rss() const {
    return GetField<int64_t>(VT_OVERALL_MAX_RSS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_UNCOMPRESSED_VEC_BYTES, 8) &&
           VerifyField<uint64_t>(verifier, VT_RLE_VECTOR_BYTES, 8) &&
           VerifyField<double>(verifier, VT_RLE_VECTOR_MB, 8) &&
           VerifyField<double>(verifier, VT_RELATIVE_COMPRESSION, 8) &&
           VerifyField<int64_t>(verifier, VT_OVERALL_MAX_RSS, 8) &&
           verifier.EndTable();
  }
};

struct MemoryConsumptionBuilder {
  typedef MemoryConsumption Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uncompressed_vec_bytes(uint64_t uncompressed_vec_bytes) {
    fbb_.AddElement<uint64_t>(MemoryConsumption::VT_UNCOMPRESSED_VEC_BYTES, uncompressed_vec_bytes, 0);
  }
  void add_rle_vector_bytes(uint64_t rle_vector_bytes) {
    fbb_.AddElement<uint64_t>(MemoryConsumption::VT_RLE_VECTOR_BYTES, rle_vector_bytes, 0);
  }
  void add_rle_vector_mb(double rle_vector_mb) {
    fbb_.AddElement<double>(MemoryConsumption::VT_RLE_VECTOR_MB, rle_vector_mb, 0.0);
  }
  void add_relative_compression(double relative_compression) {
    fbb_.AddElement<double>(MemoryConsumption::VT_RELATIVE_COMPRESSION, relative_compression, 0.0);
  }
  void add_overall_max_rss(int64_t overall_max_rss) {
    fbb_.AddElement<int64_t>(MemoryConsumption::VT_OVERALL_MAX_RSS, overall_max_rss, 0);
  }
  explicit MemoryConsumptionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MemoryConsumption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MemoryConsumption>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MemoryConsumption> CreateMemoryConsumption(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t uncompressed_vec_bytes = 0,
    uint64_t rle_vector_bytes = 0,
    double rle_vector_mb = 0.0,
    double relative_compression = 0.0,
    int64_t overall_max_rss = 0) {
  MemoryConsumptionBuilder builder_(_fbb);
  builder_.add_overall_max_rss(overall_max_rss);
  builder_.add_relative_compression(relative_compression);
  builder_.add_rle_vector_mb(rle_vector_mb);
  builder_.add_rle_vector_bytes(rle_vector_bytes);
  builder_.add_uncompressed_vec_bytes(uncompressed_vec_bytes);
  return builder_.Finish();
}

inline const StreamCPIInfo::Partition *GetPartition(const void *buf) {
  return ::flatbuffers::GetRoot<StreamCPIInfo::Partition>(buf);
}

inline const StreamCPIInfo::Partition *GetSizePrefixedPartition(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<StreamCPIInfo::Partition>(buf);
}

inline bool VerifyPartitionBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<StreamCPIInfo::Partition>(nullptr);
}

inline bool VerifySizePrefixedPartitionBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<StreamCPIInfo::Partition>(nullptr);
}

inline void FinishPartitionBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<StreamCPIInfo::Partition> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPartitionBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<StreamCPIInfo::Partition> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace StreamCPIInfo

#endif  // FLATBUFFERS_GENERATED_STREAMCPIINFO_STREAMCPIINFO_H_
